/* eslint-disable no-restricted-properties */
/** normalize
 * This lets us translate a value from one scale to another.
 *
 * @param value - Our initial value to translate
 * @param min - the current minimum value possible
 * @param max - the current maximum value possible
 * @param scaleMin - the min value of the scale we're translating to
 * @param scaleMax - the max value of the scale we're translating to
 * @returns the value on its new scale
 */
export function normalize(value, min, max, scaleMin = 0, scaleMax = 1) {
    // If the `min` and `max` are the same value, it means our dataset is flat.
    // For now, let's assume that flat data should be aligned to the bottom.
    if (min === max) {
        return scaleMin;
    }
    return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
}
/** moveTo
 * the coordinate that lies at a midpoint between 2 lines, based on the radius
 *
 * @param to - Our initial point
 * @param to.x - The x value of our initial point
 * @param to.y - The y value of our initial point
 * @param from - Our final point
 * @param from.x - The x value of our final point
 * @param from.y - The y value of our final point
 * @param radius - The distance away from the final point
 * @returns an object holding the x/y coordinates of the midpoint.
 */
export function moveTo(to, from, radius) {
    const length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
    const unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
    return {
        x: from.x + unitVector.x * radius,
        y: from.y + unitVector.y * radius,
    };
}
/** getDistanceBetween
 * Simple formula derived from pythagoras to calculate the distance between
 * 2 points on a plane.
 *
 * @param p1 - Our initial point
 * @param p1.x - The x value of our initial point
 * @param p1.y - The y value of our initial point
 * @param p2 - Our final point
 * @param p2.x - The x value of our final point
 * @param p2.y - The y value of our final point
 * @returns the distance between the points.
 */
export const getDistanceBetween = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
/** checkForCollinearPoints
 * Figure out if the midpoint fits perfectly on a line between the two others.
 *
 * @param p1 - Our initial point
 * @param p1.x - The x value of our initial point
 * @param p1.y - The y value of our initial point
 * @param p2 - Our mid-point
 * @param p2.x - The x value of our mid-point
 * @param p2.y - The y value of our mid-point
 * @param p3 - Our final point
 * @param p3.x - The x value of our final point
 * @param p3.y - The y value of our final point
 * @returns whether or not p2 sits on the line between p1 and p3.
 */
export const checkForCollinearPoints = (p1, p2, p3) => (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aC5oZWxwZXJzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXRyZW5kLyIsInNvdXJjZXMiOlsiaGVscGVycy9tYXRoLmhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkNBQTZDO0FBRTdDOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQ3ZCLEtBQWEsRUFDYixHQUFXLEVBQ1gsR0FBVyxFQUNYLFFBQVEsR0FBRyxDQUFDLEVBQ1osUUFBUSxHQUFHLENBQUM7SUFFWiwyRUFBMkU7SUFDM0Usd0VBQXdFO0lBQ3hFLElBQUksR0FBRyxLQUFLLEdBQUcsRUFBRTtRQUNmLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO0lBRUQsT0FBTyxRQUFRLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQU9EOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FBQyxFQUFTLEVBQUUsSUFBVyxFQUFFLE1BQWM7SUFDM0QsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEcsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFFaEYsT0FBTztRQUNMLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsTUFBTTtRQUNqQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLE1BQU07S0FDbEMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFHLENBQUMsRUFBUyxFQUFFLEVBQVMsRUFBRSxFQUFFLENBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUVqRTs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxFQUFTLEVBQUUsRUFBUyxFQUFFLEVBQVMsRUFBRSxFQUFFLENBQ3pFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuLyoqIG5vcm1hbGl6ZVxuICogVGhpcyBsZXRzIHVzIHRyYW5zbGF0ZSBhIHZhbHVlIGZyb20gb25lIHNjYWxlIHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gT3VyIGluaXRpYWwgdmFsdWUgdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0gbWluIC0gdGhlIGN1cnJlbnQgbWluaW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIG1heCAtIHRoZSBjdXJyZW50IG1heGltdW0gdmFsdWUgcG9zc2libGVcbiAqIEBwYXJhbSBzY2FsZU1pbiAtIHRoZSBtaW4gdmFsdWUgb2YgdGhlIHNjYWxlIHdlJ3JlIHRyYW5zbGF0aW5nIHRvXG4gKiBAcGFyYW0gc2NhbGVNYXggLSB0aGUgbWF4IHZhbHVlIG9mIHRoZSBzY2FsZSB3ZSdyZSB0cmFuc2xhdGluZyB0b1xuICogQHJldHVybnMgdGhlIHZhbHVlIG9uIGl0cyBuZXcgc2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShcbiAgdmFsdWU6IG51bWJlcixcbiAgbWluOiBudW1iZXIsXG4gIG1heDogbnVtYmVyLFxuICBzY2FsZU1pbiA9IDAsXG4gIHNjYWxlTWF4ID0gMSxcbikge1xuICAvLyBJZiB0aGUgYG1pbmAgYW5kIGBtYXhgIGFyZSB0aGUgc2FtZSB2YWx1ZSwgaXQgbWVhbnMgb3VyIGRhdGFzZXQgaXMgZmxhdC5cbiAgLy8gRm9yIG5vdywgbGV0J3MgYXNzdW1lIHRoYXQgZmxhdCBkYXRhIHNob3VsZCBiZSBhbGlnbmVkIHRvIHRoZSBib3R0b20uXG4gIGlmIChtaW4gPT09IG1heCkge1xuICAgIHJldHVybiBzY2FsZU1pbjtcbiAgfVxuXG4gIHJldHVybiBzY2FsZU1pbiArICh2YWx1ZSAtIG1pbikgKiAoc2NhbGVNYXggLSBzY2FsZU1pbikgLyAobWF4IC0gbWluKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufVxuXG4vKiogbW92ZVRvXG4gKiB0aGUgY29vcmRpbmF0ZSB0aGF0IGxpZXMgYXQgYSBtaWRwb2ludCBiZXR3ZWVuIDIgbGluZXMsIGJhc2VkIG9uIHRoZSByYWRpdXNcbiAqXG4gKiBAcGFyYW0gdG8gLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHRvLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHRvLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIGZyb20gLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSByYWRpdXMgLSBUaGUgZGlzdGFuY2UgYXdheSBmcm9tIHRoZSBmaW5hbCBwb2ludFxuICogQHJldHVybnMgYW4gb2JqZWN0IGhvbGRpbmcgdGhlIHgveSBjb29yZGluYXRlcyBvZiB0aGUgbWlkcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlVG8odG86IFBvaW50LCBmcm9tOiBQb2ludCwgcmFkaXVzOiBudW1iZXIpOiBQb2ludCB7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCgodG8ueCAtIGZyb20ueCkgKiAodG8ueCAtIGZyb20ueCkgKyAodG8ueSAtIGZyb20ueSkgKiAodG8ueSAtIGZyb20ueSkpO1xuICBjb25zdCB1bml0VmVjdG9yID0geyB4OiAodG8ueCAtIGZyb20ueCkgLyBsZW5ndGgsIHk6ICh0by55IC0gZnJvbS55KSAvIGxlbmd0aCB9O1xuXG4gIHJldHVybiB7XG4gICAgeDogZnJvbS54ICsgdW5pdFZlY3Rvci54ICogcmFkaXVzLFxuICAgIHk6IGZyb20ueSArIHVuaXRWZWN0b3IueSAqIHJhZGl1cyxcbiAgfTtcbn1cblxuLyoqIGdldERpc3RhbmNlQmV0d2VlblxuICogU2ltcGxlIGZvcm11bGEgZGVyaXZlZCBmcm9tIHB5dGhhZ29yYXMgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG4gKiAyIHBvaW50cyBvbiBhIHBsYW5lLlxuICpcbiAqIEBwYXJhbSBwMSAtIE91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDEueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDEueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDIgLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMi54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDIueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERpc3RhbmNlQmV0d2VlbiA9IChwMTogUG9pbnQsIHAyOiBQb2ludCkgPT5cbiAgTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG5cbi8qKiBjaGVja0ZvckNvbGxpbmVhclBvaW50c1xuICogRmlndXJlIG91dCBpZiB0aGUgbWlkcG9pbnQgZml0cyBwZXJmZWN0bHkgb24gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBvdGhlcnMuXG4gKlxuICogQHBhcmFtIHAxIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMiAtIE91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMi54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDMgLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMy54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDMueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgcDIgc2l0cyBvbiB0aGUgbGluZSBiZXR3ZWVuIHAxIGFuZCBwMy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzID0gKHAxOiBQb2ludCwgcDI6IFBvaW50LCBwMzogUG9pbnQpID0+XG4gIChwMS55IC0gcDIueSkgKiAocDEueCAtIHAzLngpID09PSAocDEueSAtIHAzLnkpICogKHAxLnggLSBwMi54KTtcbiJdfQ==