import * as tslib_1 from "tslib";
import { animate, keyframes, state, style, transition, trigger, } from '@angular/animations';
import { Component, Input, ViewChild, } from '@angular/core';
import { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';
import { normalize } from '../helpers/math.helpers';
import { generateId } from '../helpers/misc.helpers';
import { normalizeDataset } from './trend.helpers';
let TrendComponent = class TrendComponent {
    constructor() {
        this.autoDraw = false;
        this.autoDrawDuration = 2000;
        this.autoDrawEasing = 'ease';
        this.padding = 8;
        this.radius = 10;
        this.stroke = 'black';
        this.strokeLinecap = '';
        this.strokeWidth = 1;
        this.gradient = [];
        this.svgHeight = '25%';
        this.svgWidth = '100%';
        this.animationState = '';
        this.id = generateId();
        this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;
    }
    ngOnChanges() {
        // We need at least 2 points to draw a graph.
        if (!this.data || this.data.length < 2) {
            return;
        }
        // `data` can either be an array of numbers:
        // [1, 2, 3]
        // or, an array of objects containing a value:
        // [{ value: 1 }, { value: 2 }, { value: 3 }]
        //
        // For now, we're just going to convert the second form to the first.
        // Later on, if/when we support tooltips, we may adjust.
        const plainValues = this.data.map((point) => {
            if (typeof point === 'number') {
                return point;
            }
            return point.value;
        });
        // Our viewbox needs to be in absolute units, so we'll default to 300x75
        // Our SVG can be a %, though; this is what makes it scalable.
        // By defaulting to percentages, the SVG will grow to fill its parent
        // container, preserving a 1/4 aspect ratio.
        const viewBoxWidth = this.width || 300;
        const viewBoxHeight = this.height || 75;
        this.svgWidth = this.width || '100%';
        this.svgHeight = this.height || '25%';
        this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;
        const root = location.href.split(location.hash || '#')[0];
        this.pathStroke = (this.gradient && this.gradient.length) ? `url('${root}#${this.gradientId}')` : undefined;
        this.gradientTrimmed = this.gradient.slice().reverse().map((val, idx) => {
            return {
                idx,
                stopColor: val,
                offset: normalize(idx, 0, this.gradient.length - 1 || 1),
            };
        });
        const normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
        // NOTE: Because SVGs are indexed from the top left, but most data is
        // indexed from the bottom left, we're inverting the Y min/max.
        viewBoxHeight - this.padding, this.padding);
        if (this.autoDraw && this.animationState !== 'active') {
            this.animationState = 'inactive';
            setTimeout(() => {
                this.lineLength = this.pathEl.nativeElement.getTotalLength();
                this.animationState = 'active';
            });
        }
        this.d = this.smooth
            ? buildSmoothPath(normalizedValues, this.radius)
            : buildLinearPath(normalizedValues);
    }
};
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "data", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "smooth", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "autoDraw", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "autoDrawDuration", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "autoDrawEasing", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "width", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "height", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "padding", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "radius", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "stroke", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "strokeLinecap", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "strokeWidth", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "gradient", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "preserveAspectRatio", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "svgHeight", void 0);
tslib_1.__decorate([
    Input()
], TrendComponent.prototype, "svgWidth", void 0);
tslib_1.__decorate([
    ViewChild('pathEl', { static: false })
], TrendComponent.prototype, "pathEl", void 0);
TrendComponent = tslib_1.__decorate([
    Component({
        selector: 'ngx-trend',
        template: `
  <svg *ngIf="data && data.length >= 2"
    [attr.width]="svgWidth"
    [attr.height]="svgHeight"
    [attr.stroke]="stroke"
    [attr.stroke-width]="strokeWidth"
    [attr.stroke-linecap]="strokeLinecap"
    [attr.viewBox]="viewBox"
    [attr.preserveAspectRatio]="preserveAspectRatio"
  >
    <defs *ngIf="gradient && gradient.length">
      <linearGradient [attr.id]="gradientId" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop
          *ngFor="let g of gradientTrimmed;"
          [attr.key]="g.idx"
          [attr.offset]="g.offset"
          [attr.stop-color]="g.stopColor"
        />
      </linearGradient>
    </defs>
    <path fill="none" #pathEl
      [attr.stroke]="pathStroke" [attr.d]="d"
      [@pathAnimaiton]="{
        value: animationState,
        params: {
          autoDrawDuration: autoDrawDuration,
          autoDrawEasing: autoDrawEasing,
          lineLength: lineLength
        }
      }" />
  </svg>
  `,
        animations: [
            trigger('pathAnimaiton', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ display: 'initial' }),
                    // We do the animation using the dash array/offset trick
                    // https://css-tricks.com/svg-line-animation-works/
                    animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                        style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': '{{ lineLength }}px',
                        }),
                        style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': 0,
                        }),
                    ])),
                    // One unfortunate side-effect of the auto-draw is that the line is
                    // actually 1 big dash, the same length as the line itself. If the
                    // line length changes (eg. radius change, new data), that dash won't
                    // be the same length anymore. We can fix that by removing those
                    // properties once the auto-draw is completed.
                    style({
                        'stroke-dashoffset': '',
                        'stroke-dasharray': '',
                    }),
                ]),
            ]),
        ]
    })
], TrendComponent);
export { TrendComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXRyZW5kLyIsInNvdXJjZXMiOlsidHJlbmQvdHJlbmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsT0FBTyxFQUNQLFNBQVMsRUFDVCxLQUFLLEVBQ0wsS0FBSyxFQUNMLFVBQVUsRUFDVixPQUFPLEdBQ1IsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQ0wsU0FBUyxFQUVULEtBQUssRUFFTCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBcUVuRCxJQUFhLGNBQWMsR0FBM0IsTUFBYSxjQUFjO0lBMkJ6QjtRQXZCUyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLHFCQUFnQixHQUFHLElBQUksQ0FBQztRQUN4QixtQkFBYyxHQUFHLE1BQU0sQ0FBQztRQUd4QixZQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ1osV0FBTSxHQUFHLEVBQUUsQ0FBQztRQUNaLFdBQU0sR0FBRyxPQUFPLENBQUM7UUFDakIsa0JBQWEsR0FBRyxFQUFFLENBQUM7UUFDbkIsZ0JBQVcsR0FBRyxDQUFDLENBQUM7UUFDaEIsYUFBUSxHQUFhLEVBQUUsQ0FBQztRQUV4QixjQUFTLEdBQW9CLEtBQUssQ0FBQztRQUNuQyxhQUFRLEdBQW9CLE1BQU0sQ0FBQztRQVE1QyxtQkFBYyxHQUFHLEVBQUUsQ0FBQztRQUdsQixJQUFJLENBQUMsRUFBRSxHQUFHLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsK0JB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bURBQW1EO29CQUNuRCxPQUFPLENBQUMsK0NBQStDLEVBQ3JELFNBQVMsQ0FBQzt3QkFDUixLQUFLLENBQUM7NEJBQ0osa0JBQWtCLEVBQUUsb0JBQW9COzRCQUN4QyxtQkFBbUIsRUFBRSxvQkFBb0I7eUJBQzFDLENBQUM7d0JBQ0YsS0FBSyxDQUFDOzRCQUNKLGtCQUFrQixFQUFFLG9CQUFvQjs0QkFDeEMsbUJBQW1CLEVBQUUsQ0FBQzt5QkFDdkIsQ0FBQztxQkFDSCxDQUFDLENBQ0g7b0JBQ0QsbUVBQW1FO29CQUNuRSxrRUFBa0U7b0JBQ2xFLHFFQUFxRTtvQkFDckUsZ0VBQWdFO29CQUNoRSw4Q0FBOEM7b0JBQzlDLEtBQUssQ0FBQzt3QkFDSixtQkFBbUIsRUFBRSxFQUFFO3dCQUN2QixrQkFBa0IsRUFBRSxFQUFFO3FCQUN2QixDQUFDO2lCQUNILENBQUM7YUFDSCxDQUFDO1NBQ0g7S0FDRixDQUFDO0dBQ1csY0FBYyxDQTRGMUI7U0E1RlksY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGFuaW1hdGUsXG4gIGtleWZyYW1lcyxcbiAgc3RhdGUsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uLFxuICB0cmlnZ2VyLFxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgYnVpbGRMaW5lYXJQYXRoLCBidWlsZFNtb290aFBhdGggfSBmcm9tICcuLi9oZWxwZXJzL0RPTS5oZWxwZXJzJztcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL2hlbHBlcnMvbWF0aC5oZWxwZXJzJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi9oZWxwZXJzL21pc2MuaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemVEYXRhc2V0IH0gZnJvbSAnLi90cmVuZC5oZWxwZXJzJztcblxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ3gtdHJlbmQnLFxuICB0ZW1wbGF0ZTogYFxuICA8c3ZnICpuZ0lmPVwiZGF0YSAmJiBkYXRhLmxlbmd0aCA+PSAyXCJcbiAgICBbYXR0ci53aWR0aF09XCJzdmdXaWR0aFwiXG4gICAgW2F0dHIuaGVpZ2h0XT1cInN2Z0hlaWdodFwiXG4gICAgW2F0dHIuc3Ryb2tlXT1cInN0cm9rZVwiXG4gICAgW2F0dHIuc3Ryb2tlLXdpZHRoXT1cInN0cm9rZVdpZHRoXCJcbiAgICBbYXR0ci5zdHJva2UtbGluZWNhcF09XCJzdHJva2VMaW5lY2FwXCJcbiAgICBbYXR0ci52aWV3Qm94XT1cInZpZXdCb3hcIlxuICAgIFthdHRyLnByZXNlcnZlQXNwZWN0UmF0aW9dPVwicHJlc2VydmVBc3BlY3RSYXRpb1wiXG4gID5cbiAgICA8ZGVmcyAqbmdJZj1cImdyYWRpZW50ICYmIGdyYWRpZW50Lmxlbmd0aFwiPlxuICAgICAgPGxpbmVhckdyYWRpZW50IFthdHRyLmlkXT1cImdyYWRpZW50SWRcIiB4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMCVcIiB5Mj1cIjEwMCVcIj5cbiAgICAgICAgPHN0b3BcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgZyBvZiBncmFkaWVudFRyaW1tZWQ7XCJcbiAgICAgICAgICBbYXR0ci5rZXldPVwiZy5pZHhcIlxuICAgICAgICAgIFthdHRyLm9mZnNldF09XCJnLm9mZnNldFwiXG4gICAgICAgICAgW2F0dHIuc3RvcC1jb2xvcl09XCJnLnN0b3BDb2xvclwiXG4gICAgICAgIC8+XG4gICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgIDwvZGVmcz5cbiAgICA8cGF0aCBmaWxsPVwibm9uZVwiICNwYXRoRWxcbiAgICAgIFthdHRyLnN0cm9rZV09XCJwYXRoU3Ryb2tlXCIgW2F0dHIuZF09XCJkXCJcbiAgICAgIFtAcGF0aEFuaW1haXRvbl09XCJ7XG4gICAgICAgIHZhbHVlOiBhbmltYXRpb25TdGF0ZSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgYXV0b0RyYXdEdXJhdGlvbjogYXV0b0RyYXdEdXJhdGlvbixcbiAgICAgICAgICBhdXRvRHJhd0Vhc2luZzogYXV0b0RyYXdFYXNpbmcsXG4gICAgICAgICAgbGluZUxlbmd0aDogbGluZUxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdwYXRoQW5pbWFpdG9uJywgW1xuICAgICAgc3RhdGUoJ2luYWN0aXZlJywgc3R5bGUoeyBkaXNwbGF5OiAnbm9uZScgfSkpLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLCBbXG4gICAgICAgIHN0eWxlKHsgZGlzcGxheTogJ2luaXRpYWwnIH0pLFxuICAgICAgICAvLyBXZSBkbyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBkYXNoIGFycmF5L29mZnNldCB0cmlja1xuICAgICAgICAvLyBodHRwczovL2Nzcy10cmlja3MuY29tL3N2Zy1saW5lLWFuaW1hdGlvbi13b3Jrcy9cbiAgICAgICAgYW5pbWF0ZSgne3sgYXV0b0RyYXdEdXJhdGlvbiB9fW1zIHt7IGF1dG9EcmF3RWFzaW5nIH19JyxcbiAgICAgICAgICBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAwLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSksXG4gICAgICAgICksXG4gICAgICAgIC8vIE9uZSB1bmZvcnR1bmF0ZSBzaWRlLWVmZmVjdCBvZiB0aGUgYXV0by1kcmF3IGlzIHRoYXQgdGhlIGxpbmUgaXNcbiAgICAgICAgLy8gYWN0dWFsbHkgMSBiaWcgZGFzaCwgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBsaW5lIGl0c2VsZi4gSWYgdGhlXG4gICAgICAgIC8vIGxpbmUgbGVuZ3RoIGNoYW5nZXMgKGVnLiByYWRpdXMgY2hhbmdlLCBuZXcgZGF0YSksIHRoYXQgZGFzaCB3b24ndFxuICAgICAgICAvLyBiZSB0aGUgc2FtZSBsZW5ndGggYW55bW9yZS4gV2UgY2FuIGZpeCB0aGF0IGJ5IHJlbW92aW5nIHRob3NlXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb25jZSB0aGUgYXV0by1kcmF3IGlzIGNvbXBsZXRlZC5cbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICcnLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJycsXG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyZW5kQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgaWQ6IG51bWJlcjtcbiAgQElucHV0KCkgZGF0YTogKG51bWJlciB8IHt2YWx1ZTogbnVtYmVyfSlbXTtcbiAgQElucHV0KCkgc21vb3RoOiBib29sZWFuO1xuICBASW5wdXQoKSBhdXRvRHJhdyA9IGZhbHNlO1xuICBASW5wdXQoKSBhdXRvRHJhd0R1cmF0aW9uID0gMjAwMDtcbiAgQElucHV0KCkgYXV0b0RyYXdFYXNpbmcgPSAnZWFzZSc7XG4gIEBJbnB1dCgpIHdpZHRoOiBudW1iZXI7XG4gIEBJbnB1dCgpIGhlaWdodDogbnVtYmVyO1xuICBASW5wdXQoKSBwYWRkaW5nID0gODtcbiAgQElucHV0KCkgcmFkaXVzID0gMTA7XG4gIEBJbnB1dCgpIHN0cm9rZSA9ICdibGFjayc7XG4gIEBJbnB1dCgpIHN0cm9rZUxpbmVjYXAgPSAnJztcbiAgQElucHV0KCkgc3Ryb2tlV2lkdGggPSAxO1xuICBASW5wdXQoKSBncmFkaWVudDogc3RyaW5nW10gPSBbXTtcbiAgQElucHV0KCkgcHJlc2VydmVBc3BlY3RSYXRpbzogc3RyaW5nO1xuICBASW5wdXQoKSBzdmdIZWlnaHQ6IHN0cmluZyB8IG51bWJlciA9ICcyNSUnO1xuICBASW5wdXQoKSBzdmdXaWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzEwMCUnO1xuICBAVmlld0NoaWxkKCdwYXRoRWwnLCB7IHN0YXRpYzogZmFsc2UgfSkgcGF0aEVsOiBFbGVtZW50UmVmO1xuICBncmFkaWVudFRyaW1tZWQ6IGFueVtdO1xuICBkOiBhbnk7XG4gIHZpZXdCb3g6IHN0cmluZztcbiAgcGF0aFN0cm9rZTogYW55O1xuICBncmFkaWVudElkOiBzdHJpbmc7XG4gIGxpbmVMZW5ndGg6IG51bWJlcjtcbiAgYW5pbWF0aW9uU3RhdGUgPSAnJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuZ3JhZGllbnRJZCA9IGBuZ3gtdHJlbmQtdmVydGljYWwtZ3JhZGllbnQtJHt0aGlzLmlkfWA7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cyB0byBkcmF3IGEgZ3JhcGguXG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBgZGF0YWAgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBudW1iZXJzOlxuICAgIC8vIFsxLCAyLCAzXVxuICAgIC8vIG9yLCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSB2YWx1ZTpcbiAgICAvLyBbeyB2YWx1ZTogMSB9LCB7IHZhbHVlOiAyIH0sIHsgdmFsdWU6IDMgfV1cbiAgICAvL1xuICAgIC8vIEZvciBub3csIHdlJ3JlIGp1c3QgZ29pbmcgdG8gY29udmVydCB0aGUgc2Vjb25kIGZvcm0gdG8gdGhlIGZpcnN0LlxuICAgIC8vIExhdGVyIG9uLCBpZi93aGVuIHdlIHN1cHBvcnQgdG9vbHRpcHMsIHdlIG1heSBhZGp1c3QuXG4gICAgY29uc3QgcGxhaW5WYWx1ZXMgPSB0aGlzLmRhdGEubWFwKChwb2ludCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50LnZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT3VyIHZpZXdib3ggbmVlZHMgdG8gYmUgaW4gYWJzb2x1dGUgdW5pdHMsIHNvIHdlJ2xsIGRlZmF1bHQgdG8gMzAweDc1XG4gICAgLy8gT3VyIFNWRyBjYW4gYmUgYSAlLCB0aG91Z2g7IHRoaXMgaXMgd2hhdCBtYWtlcyBpdCBzY2FsYWJsZS5cbiAgICAvLyBCeSBkZWZhdWx0aW5nIHRvIHBlcmNlbnRhZ2VzLCB0aGUgU1ZHIHdpbGwgZ3JvdyB0byBmaWxsIGl0cyBwYXJlbnRcbiAgICAvLyBjb250YWluZXIsIHByZXNlcnZpbmcgYSAxLzQgYXNwZWN0IHJhdGlvLlxuICAgIGNvbnN0IHZpZXdCb3hXaWR0aCA9IHRoaXMud2lkdGggfHwgMzAwO1xuICAgIGNvbnN0IHZpZXdCb3hIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCA3NTtcbiAgICB0aGlzLnN2Z1dpZHRoID0gdGhpcy53aWR0aCB8fCAnMTAwJSc7XG4gICAgdGhpcy5zdmdIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCAnMjUlJztcbiAgICB0aGlzLnZpZXdCb3ggPSBgMCAwICR7dmlld0JveFdpZHRofSAke3ZpZXdCb3hIZWlnaHR9YDtcbiAgICBjb25zdCByb290ID0gbG9jYXRpb24uaHJlZi5zcGxpdChsb2NhdGlvbi5oYXNoIHx8ICcjJylbMF07XG4gICAgdGhpcy5wYXRoU3Ryb2tlID0gKHRoaXMuZ3JhZGllbnQgJiYgdGhpcy5ncmFkaWVudC5sZW5ndGgpID8gYHVybCgnJHtyb290fSMke3RoaXMuZ3JhZGllbnRJZH0nKWAgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmdyYWRpZW50VHJpbW1lZCA9IHRoaXMuZ3JhZGllbnQuc2xpY2UoKS5yZXZlcnNlKCkubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWR4LFxuICAgICAgICBzdG9wQ29sb3I6IHZhbCxcbiAgICAgICAgb2Zmc2V0OiBub3JtYWxpemUoaWR4LCAwLCB0aGlzLmdyYWRpZW50Lmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5vcm1hbGl6ZURhdGFzZXQocGxhaW5WYWx1ZXMsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB2aWV3Qm94V2lkdGggLSB0aGlzLnBhZGRpbmcsXG4gICAgICAvLyBOT1RFOiBCZWNhdXNlIFNWR3MgYXJlIGluZGV4ZWQgZnJvbSB0aGUgdG9wIGxlZnQsIGJ1dCBtb3N0IGRhdGEgaXNcbiAgICAgIC8vIGluZGV4ZWQgZnJvbSB0aGUgYm90dG9tIGxlZnQsIHdlJ3JlIGludmVydGluZyB0aGUgWSBtaW4vbWF4LlxuICAgICAgdmlld0JveEhlaWdodCAtIHRoaXMucGFkZGluZyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuYXV0b0RyYXcgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMucGF0aEVsLm5hdGl2ZUVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kID0gdGhpcy5zbW9vdGhcbiAgICAgID8gYnVpbGRTbW9vdGhQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMsIHRoaXMucmFkaXVzKVxuICAgICAgOiBidWlsZExpbmVhclBhdGgobm9ybWFsaXplZFZhbHVlcyk7XG4gIH1cbn1cbiJdfQ==